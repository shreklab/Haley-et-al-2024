function modelExploit(expName,strainName,modelType)
% MODELEXPLOIT(EXPNAME,STRAINNAME,MODELTYPE)
%
%   MODELEXPLOIT fits and evaluates generalized linear models (GLMs) to
%   predict a worm's decision to exploit a food patch. The function loads
%   pre-processed encounter data, generates a set of predictor variables
%   based on foraging history (e.g., time since last exploitation, density
%   of previously visited patches), and then fits a model to predict the
%   probability of exploitation. The analysis is performed on bootstrapped
%   samples to ensure statistical robustness, and the final model
%   parameters and performance metrics are saved to a file.
%
%   INPUTS:
%       - expName [char]: Specifies the dataset to analyze (e.g.,
%           'foragingConcentration', 'foragingSensory', or 'foragingMatching').
%           Default is 'foragingConcentration'.
%       - strainName [char]: Specifies the worm strain for analysis when
%           applicable (e.g., 'well-fed', 'osm-6', or 'mec-4'). Default is
%           'well-fed'.
%       - modelType [char]: Defines the modeling approach (e.g., 'GLM' for
%           a standard GLM, 'ridge' for ridge regression, or 'combinations'
%           for testing multiple predictor combinations). Default is 'GLM'.
%
%   OUTPUTS:
%       This function does not return any variables to the MATLAB
%       workspace. Its primary output is a .mat file saved in the
%       'geometricData' folder, containing the workspace with model
%       results, including fitted coefficients (beta) and performance
%       metrics.
%
%   Written 7/11/2025 by Jess Haley in MATLAB R2024a.
%
%   See also GETFORAGINGINFO, ANALYZEFORAGING, ANALYZEENCOUNTERS,
%   ANALYZEGFP, FITGLM, LASSOGLM.

% Input argument validation
arguments
    expName {mustBeMember(expName,{'foragingConcentration','foragingSensory','foragingMatching'})} = 'foragingConcentration'
    strainName {mustBeMember(strainName,{'well-fed','osm-6','mec-4'})} = 'well-fed'
    modelType {mustBeMember(modelType,{'GLM','ridge','combinations'})} = 'GLM'
end

%% Load data into workspace

path = 'Z:\jhaley\foragingPaper\';
addpath(genpath(path))
load(fullfile(path,'encounter.mat'),'encounter');
load(fullfile(path,expName,'experimentInfo.mat'),'info');
load(fullfile(path,expName,'midpoint.mat'),'data');
if strcmp(modelType,'GLM') & strcmp(expName,'foragingSensory')
    load(fullfile(path,'geometricData',['geometricData_',strainName,'_ridge.mat']),'lambda','bestLambda')
end

%% Get conditions to analyze

[G,GID] = findgroups(encounter(:,{'expName','lawnVolume',...
    'growthCondition','OD600Label','strainName','strainID'}));

if strcmp(expName,'foragingConcentration')
    conditionG = find(strcmp(GID.expName,expName) & GID.lawnVolume == 0.5 & ...
        ~(strcmp(GID.OD600Label,'0.10') & GID.growthCondition == 48));
elseif strcmp(expName,'foragingSensory')
    conditionG = find(strcmp(GID.strainName,strainName) & ...
        (strcmp(GID.expName,expName) | strcmp(GID.expName,'foragingMutants')));
else
    conditionG = find(strcmp(GID.expName,expName));
end
numGroups = length(conditionG);

%% Get average estimated amplitude of each condition and normalize to OD = 10 (0.5 uL)

borderAmp = splitapply(@(X) mean(X,'omitnan'),encounter.borderAmplitude,G);
relativeBorder = borderAmp(conditionG);
borderAmp10 = borderAmp(strcmp(GID.expName,'foragingConcentration') & ...
    strcmp(GID.OD600Label,'10.00') & GID.lawnVolume == 0.5);
borderAmp0 = 1e-2; % assign 0 to 0.01
relativeBorder = 10.*relativeBorder./borderAmp10;
relativeBorder(strcmp(GID.OD600Label(conditionG),'0.00')) = borderAmp0;

%% Get ids for worms used in this model

% Get unique worm identifier across experiments
[wormID,wormIDInfo] = findgroups(table(G,encounter.wormNum,'VariableNames',{'conditionNum','wormNum'}));

% Remove worms tracked for less than 75% of the video
if strcmp(expName,'foragingConcentration') | strcmp(expName,'foragingMatching')
    wormNums = unique(wormID(ismember(G,conditionG) & ~encounter.exclude));
    framesTracked = arrayfun(@(w) sum(~data.noTrack(data.wormNum == w))/...
        sum(info.numFrames(info.plateNum == unique(data.plateNum(data.wormNum == w)))), wormIDInfo.wormNum(wormNums));
elseif strcmp(expName,'foragingSensory')
    wormNumsSensory = unique(wormID(ismember(G,conditionG) & ~encounter.exclude & ...
        ismember(G,find(strcmp(GID.expName,expName)))));
    framesTrackedSensory = arrayfun(@(w) sum(~data.noTrack(data.wormNum == w))/...
        sum(info.numFrames(info.plateNum == unique(data.plateNum(data.wormNum == w)))), wormIDInfo.wormNum(wormNumsSensory));
    wormNumsMutants = unique(wormID(ismember(G,conditionG) & ~encounter.exclude & ...
        ismember(G,find(strcmp(GID.expName,'foragingMutants')))));
    load(fullfile(path,'foragingMutants','experimentInfo.mat'),'info');
    load(fullfile(path,'foragingMutants','midpoint.mat'),'data');
    framesTrackedMutants = arrayfun(@(w) sum(~data.noTrack(data.wormNum == w))/...
        sum(info.numFrames(info.plateNum == unique(data.plateNum(data.wormNum == w)))), wormIDInfo.wormNum(wormNumsMutants));
    wormNums = [wormNumsMutants;wormNumsSensory];
    framesTracked = [framesTrackedMutants;framesTrackedSensory];
end
wormNums = wormNums(framesTracked >= 0.75);
numWorms = length(wormNums)

% Get condition id of each worm
wormGroup = arrayfun(@(w) unique(G(wormID == w & ismember(G,conditionG))),wormNums);
[~,~,wormGroupInd] = unique(wormGroup); % continuous group id

% Get indices of encounters
indEncounter = ismember(wormID,wormNums) & ~encounter.exclude;

% Get relative border amplitude for each worm
wormBorder = arrayfun(@(w) max([10*min(encounter.borderAmplitude(wormID == w & ...
    ismember(G,conditionG) & indEncounter))/borderAmp10,borderAmp0]),wormNums);

%% Equation to Compute LogLikelihood

% Compute log likelihood manually (why does matlab use the gammaln offsets?)
% y = observed p(exploit), n = # binomial trials, p = predicted p(exploit)
logLikelihood = @(y,n,p) sum(y.*log(p) + (1-y).*log(1-p) + gammaln(n+1) - gammaln(y+1) - gammaln(n-y+1));

%% Probabilistically build observations from sense posterior

if strcmp(expName,'foragingConcentration') | strcmp(expName,'foragingMatching')

% Build model table from subset of encounter table
densityK = log10(max(10*encounter.borderAmplitude./borderAmp10,borderAmp0));
densityGrowth = log10(10*encounter.borderAmplitudeGrowth/borderAmp10);
indEncounter = 1:height(encounter);
vars = table(G,encounter.wormNum,wormID,encounter.id,encounter.lawnOD600,densityK,...
    encounter.sensePosterior,encounter.exploitPosterior,encounter.timeEnter./3600,...
    encounter.timeExit./3600,encounter.duration./3600,densityGrowth,...
    encounter.exclude,encounter.censorEnter,encounter.censorExit,indEncounter',...
    'VariableNames',{'conditionNum','wormNum','wormID','encounterID','ODK','densityK',...
    'senseK','exploitK','timeEnter','timeExit','duration','densityGrowth',...
    'exclude','censorEnter','censorExit','indEncounter'});

nReps = 100; % # of simulations
modelVars = cell(nReps,1);
for n = 1:nReps

    theseVars = vars;

    % Use posterior probabilites of sensing as inclusion criteria
    includeEncounters = rand(height(vars),1) <= vars.senseK;
    theseVars = theseVars(includeEncounters,:);

    % Get encounter number
    encounterNum = arrayfun(@(id) 1:sum(wormID == id & includeEncounters),...
        unique(wormID,'stable'),'UniformOutput',false);
    theseVars.encounterNum = horzcat(encounterNum{:})';

    % Simulate exploitation event
    theseVars.exploit = rand(height(theseVars),1) <= theseVars.exploitK;

    % Get cumulative time on and off patch
    timeOn = arrayfun(@(id) cumsum(vars.duration(wormID == id & includeEncounters)),...
        unique(wormID,'stable'),'UniformOutput',false);
    theseVars.timeOn = vertcat(timeOn{:});
    theseVars.timeOn = theseVars.timeOn - theseVars.duration;
    theseVars.timeOff = theseVars.timeEnter - theseVars.timeOn;

    % Calculate time (total and off only) since last exploit and density of
    % last exploited patch
    theseVars.timeOffSinceExploit = theseVars.timeOff;
    theseVars.timeSinceExploit = theseVars.timeEnter;
    theseVars.densityE = theseVars.densityGrowth;
    theseVars.ODE(:) = 200;
    for i = 1:height(theseVars)
        indExploit = find(theseVars.conditionNum == theseVars.conditionNum(i) & ...
            theseVars.wormNum == theseVars.wormNum(i) & theseVars.exploit == 1);
        indReset = indExploit(i > indExploit);
        if ~isempty(indReset)
            theseVars.timeOffSinceExploit(i) = theseVars.timeOff(i) - theseVars.timeOff(indReset(end));
            theseVars.timeSinceExploit(i) = theseVars.timeEnter(i) - theseVars.timeExit(indReset(end));
            theseVars.densityE(i) = theseVars.densityK(indReset(end));
            theseVars.ODE(i) = theseVars.ODK(indReset(end));
        end
    end

    % Get density of last encountered patch (k-1)
    theseVars.densityH = theseVars.densityGrowth;
    theseVars.densityH(theseVars.encounterNum > 1) = ...
        theseVars.densityK(find(theseVars.encounterNum > 1)-1);
    theseVars.ODK1(:) = 200;
    theseVars.ODK1(theseVars.encounterNum > 1) = ...
        theseVars.ODK(find(theseVars.encounterNum > 1)-1);

    % Get search time
    ind = find(theseVars.encounterNum == 1);
    theseVars.searchTime(ind) = theseVars.timeEnter(ind);
    ind = find(theseVars.encounterNum > 1);
    theseVars.searchTime(ind) = theseVars.timeEnter(ind) - theseVars.timeExit(ind - 1);
    
    % Add variables
    modelVars{n} = theseVars;
    modelVars{n} = addvars(modelVars{n},repmat(n,size(theseVars,1),1),...
        'NewVariableNames','repNum','Before','conditionNum');
end
else
    load(fullfile(path,'geometricData','geometricData.mat'),'modelVars');
    nReps = length(modelVars);
end

%%  Bootstrap sample with replacement

nBoot = 500;
bootWorm = nan(numWorms,nBoot);
for b = 1:nBoot
    bootWorm(:,b) = datasample(wormNums,numWorms,'Replace',true);
end

%% Ridge regression for Sensory data set

if strcmp(modelType,'ridge')
    lambda = linspace(0,0.1,101);
    nLambda = length(lambda);
    holdOut = 0.1;
    testSize = ceil(numWorms*holdOut);
    for b = 1:nBoot
        bootWorm(:,b) = datasample(wormNums,numWorms,'Replace',false);
    end
    testWorm = bootWorm(end-testSize+1:end,:);
    bootWorm = bootWorm(1:end-testSize,:);
elseif strcmp(modelType,'GLM') & strcmp(expName,'foragingSensory')
    lambdaModel = lambda(round(mean(bestLambda,'all')));
end

%% Multinomial Logistic Regression

predictors = {'densityK','timeOffSinceExploit','densityH','densityE'};
response = 'exploitK';
nModels = length(predictors)+1;
if strcmp(modelType,'combinations')
    combos = predictors';
    for i = 2:length(predictors)-1
        temp = predictors(nchoosek(1:length(predictors),i));
        for t = 1:length(temp)
            combos = [combos;{temp(t,:)}];
        end
    end
    combos = [combos;{predictors}];
    nModels = length(combos)+1;
elseif strcmp(expName,'foragingMatching')
    predictors = {'densityK','timeOffSinceExploit','timeOff','densityH','densityE'};
    nModels = 3;
end
gridSearch = 1;
if strcmp(expName,'foragingConcentration')
    beta = cell(nModels,1);
    AIC = nan(nModels,nReps,nBoot);
    BIC = nan(nModels,nReps,nBoot);
    logLike = nan(nModels,nReps,nBoot);
    betaShuffle = nan(nModels,nReps,nBoot);
elseif strcmp(expName,'foragingMatching')
    beta = cell(nModels,1);
    AIC = nan(nModels,nReps,nBoot);
    BIC = nan(nModels,nReps,nBoot);
    logLike = nan(nModels,nReps,nBoot);
    betaShuffle = cell(nModels,1);
elseif strcmp(modelType,'ridge')
    beta = nan(nModels,nLambda,nReps,nBoot);
    logLike = nan(nLambda,nReps,nBoot);
    gridSearch = 2;
    meanLogLike = nan(nLambda,gridSearch);
    bestLambda = nan(nReps,nBoot);
else
    beta = nan(nModels,nReps,nBoot);
    betaShuffle = nan(nModels,nReps,nBoot);
end
binoSize = 1;

for g = 1:gridSearch
    if g == 2
        lambda = lambda(bestLambda) + (-50e-4:1e-4:50e-4);
    end
for n = 1:nReps
    tic
    % Get variables for this model
    include = ~modelVars{n}.exclude & ...
        ismember(modelVars{n}.conditionNum,conditionG);
    theseVars = modelVars{n}(include,['wormID',predictors,response,'exploit']);

    for b = 1:nBoot
        ind = arrayfun(@(id) find(theseVars.wormID == id),...
            bootWorm(:,b),'UniformOutput',false);
        ind = vertcat(ind{:});
        
        if strcmp(expName,'foragingConcentration') & strcmp(modelType,'GLM')
            for m = 1:nModels
                if m == 1
                    modelSpec = 'constant';
                else
                    modelSpec = 'linear';
                end
                mdl = fitglm(theseVars(ind,:),modelSpec,'Distribution','binomial',...
                    'PredictorVars',predictors(1:min(max(m-1,1),length(predictors))),...
                    'ResponseVar',response,'binomialSize',1,...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');

                % Get coefficients and AIC/BIC
                beta{m}(:,n,b) = mdl.Coefficients.Estimate;
                AIC(m,n,b) = mdl.ModelCriterion.AIC;
                BIC(m,n,b) = mdl.ModelCriterion.BIC;
                logLike(m,n,b) = mdl.LogLikelihood;
            end
        elseif strcmp(expName,'foragingConcentration') & strcmp(modelType,'combinations')
            for m = 1:nModels
                if m == 1
                    modelSpec = 'constant';
                else
                    modelSpec = 'linear';
                end
                mdl = fitglm(theseVars(ind,:),modelSpec,'Distribution','binomial',...
                    'PredictorVars',combos{max(m-1,1)},...
                    'ResponseVar',response,'binomialSize',1,...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');

                % Get coefficients and AIC/BIC
                beta{m}(:,n,b) = mdl.Coefficients.Estimate;
                AIC(m,n,b) = mdl.ModelCriterion.AIC;
                BIC(m,n,b) = mdl.ModelCriterion.BIC;
                logLike(m,n,b) = mdl.LogLikelihood;
            end
        elseif strcmp(expName,'foragingMatching')
            for m = 1:nModels
                switch m
                    case 1
                        mdl = fitglm(theseVars(ind,:),'linear','Distribution','binomial',...
                            'PredictorVars',predictors([1:2,4:5]),...
                            'ResponseVar',response,'binomialSize',1,...
                            'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                    case 2
                        mdl = fitglm(theseVars(ind,:),'linear','Distribution','binomial',...
                            'PredictorVars',predictors([1,3:5]),...
                            'ResponseVar',response,'binomialSize',1,...
                            'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                    case 3
                        mdl = fitglm(theseVars(ind,:),'linear','Distribution','binomial',...
                            'PredictorVars',predictors,...
                            'ResponseVar',response,'binomialSize',1,...
                            'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                end
                beta{m}(:,n,b) = mdl.Coefficients.Estimate;
                AIC(m,n,b) = mdl.ModelCriterion.AIC;
                BIC(m,n,b) = mdl.ModelCriterion.BIC;
                logLike(m,n,b) = mdl.LogLikelihood;
            end
        elseif strcmp(modelType,'ridge')

            % Ridge Regression
            [betaLasso,mdl] = lassoglm(theseVars{ind,predictors},...
                theseVars{ind,'exploitK'},...
                'binomial','Alpha',1e-10,'Lambda',lambda);
            beta(:,:,n,b) = [mdl.Intercept;betaLasso];

            % Check model performance w/ held out test set
            indTest = arrayfun(@(id) find(theseVars.wormID == id),...
                testWorm(:,b),'UniformOutput',false);
            indTest = vertcat(indTest{:});
            for l = 1:nLambda
                exploitK_ridge = glmval(beta(:,l,n,b),[ones(length(indTest),1),...
                    theseVars{indTest,predictors}],...
                    'logit','constant','off');
                logLike(l,n,b) = logLikelihood(theseVars{indTest,'exploitK'},1,exploitK_ridge);
            end
        else
            [betaLasso,mdl] = lassoglm(theseVars{ind,predictors},...
                theseVars{ind,'exploitK'},...
                'binomial','Alpha',1e-10,'Lambda',lambdaModel);

            % Get coefficients
            beta(:,n,b) = [mdl.Intercept;betaLasso];
        end

        % Shuffle betas
        if ~strcmp(modelType,'ridge') & ~strcmp(modelType,'combinations')
            shuffleVars = theseVars(ind,:);
            shuffleVars.exploitShuffle = shuffleVars.exploitK(randperm(height(shuffleVars)));
            if strcmp(expName,'foragingConcentration')
                mdl = fitglm(shuffleVars,'linear','Distribution','binomial',...
                    'PredictorVars',predictors,'ResponseVar','exploitShuffle',...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                betaShuffle(:,n,b) = mdl.Coefficients.Estimate;
            elseif strcmp(expName,'foragingMatching')
                 mdl = fitglm(shuffleVars,'linear','Distribution','binomial',...
                    'PredictorVars',predictors([1:2,4:5]),'ResponseVar','exploitShuffle',...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                betaShuffle{1}(:,n,b) = mdl.Coefficients.Estimate;
                mdl = fitglm(shuffleVars,'linear','Distribution','binomial',...
                    'PredictorVars',predictors([1,3:5]),'ResponseVar','exploitShuffle',...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                betaShuffle{2}(:,n,b) = mdl.Coefficients.Estimate;
                mdl = fitglm(shuffleVars,'linear','Distribution','binomial',...
                    'PredictorVars',predictors,'ResponseVar','exploitShuffle',...
                    'Options',statset('MaxIter',10000),'LikelihoodPenalty','none');
                betaShuffle{3}(:,n,b) = mdl.Coefficients.Estimate;
            elseif strcmp(expName,'foragingSensory')
                [betaLasso,mdl] = lassoglm(shuffleVars{:,predictors},shuffleVars{:,'exploitShuffle'},...
                    'binomial','Alpha',1e-10,'Lambda',lambdaModel);
                betaShuffle(:,n,b) = [mdl.Intercept;betaLasso];
            end
        end
    end
    toc
    n
end

if strcmp(modelType,'ridge')
    meanLogLike(:,g) = mean(logLike,[2,3]);
    [~,bestLambda] = max(meanLogLike(:,g)); % bestLambda should be an array, but doesn't seem to change results?
end
end

%% Plot model statistics

if strcmp(expName,'foragingConcentration') & strcmp(modelType,'GLM')
modelNames = {'β_0','ρ_k','τ_e','ρ_h','ρ_e'};
figure('Position',[100 100 800 600]);
colormap(jet)
for m = 1:nModels
    subplot(4,nModels,m); imagesc(squeeze(AIC(m,1:nReps,1:nBoot)))
    clim(prctile(AIC(:),[0 100])); title(modelNames{m})
    set(gca,'XTick',[1 nBoot],'YTick',[1 nReps])

    subplot(4,nModels,nModels+m); imagesc(squeeze(BIC(m,1:nReps,1:nBoot)))
    clim(prctile(BIC(:),[0 100]))
    set(gca,'XTick',[1 nBoot],'YTick',[1 nReps])

    subplot(4,nModels,2*nModels+m); imagesc(squeeze(beta{nModels}(m,1:nReps,1:nBoot)))
    clim(prctile(beta{nModels}(:),[0 100]))
    set(gca,'XTick',[1 nBoot],'YTick',[1 nReps])

    subplot(4,nModels,3*nModels+m); imagesc(squeeze(betaShuffle(m,1:nReps,1:nBoot)))
    clim(prctile(beta{nModels}(:),[0 100]))
    set(gca,'XTick',[1 nBoot],'YTick',[1 nReps])

end

subplot(4,nModels,1); ylabel('AIC','FontWeight','bold');
subplot(4,nModels,nModels+1); ylabel('BIC','FontWeight','bold');
subplot(4,nModels,2*nModels+1); ylabel('beta','FontWeight','bold');
subplot(4,nModels,3*nModels+1); ylabel('beta shuffled','FontWeight','bold');

ax = subplot(4,nModels,nModels); cPosition = ax.Position(1:4) + [ax.Position(3)*1.2 0 -ax.Position(3)/1.1 0];
colorbar('Position',cPosition); clim(prctile(AIC(:),[0 100]));

ax = subplot(4,nModels,2*nModels); cPosition = ax.Position(1:4) + [ax.Position(3)*1.2 0 -ax.Position(3)/1.1 0];
colorbar('Position',cPosition); clim(prctile(BIC(:),[0 100]));

ax = subplot(4,nModels,3*nModels); cPosition = ax.Position(1:4) + [ax.Position(3)*1.2 0 -ax.Position(3)/1.1 0];
colorbar('Position',cPosition); clim(prctile(beta{nModels}(:),[0 100]));

ax = subplot(4,nModels,4*nModels); cPosition = ax.Position(1:4) + [ax.Position(3)*1.2 0 -ax.Position(3)/1.1 0];
colorbar('Position',cPosition); clim(prctile(beta{nModels}(:),[0 100]));
xlabel('bootstrap'); ylabel('p(sense) shuffle');
end

%% Save model(s) and observations

if strcmp(expName,'foragingConcentration') & strcmp(modelType,'GLM')
    save(fullfile(path,'geometricData','geometricData.mat'),'modelVars','bootWorm',...
        'predictors','response','beta','betaShuffle','logLike','AIC','BIC','-v7.3');
elseif strcmp(expName,'foragingMatching')
    save(fullfile(path,'geometricData','geometricData_time.mat'),'modelVars','bootWorm',...
        'predictors','response','beta','betaShuffle','logLike','AIC','BIC','-v7.3');
elseif strcmp(expName,'foragingConcentration') & strcmp(modelType,'combinations')
    save(fullfile(path,'geometricData','geometricData_combinations.mat'),'modelVars','bootWorm',...
        'predictors','response','beta','logLike','AIC','BIC','combos','-v7.3');
elseif strcmp(expName,'foragingSensory') & strcmp(modelType,'ridge')
    save(fullfile(path,'geometricData',['geometricData_',strainName,'_ridge.mat']),'bootWorm','testWorm',...
        'predictors','response','beta','lambda','bestLambda','logLike','-v7.3')
elseif strcmp(expName,'foragingSensory') & strcmp(modelType,'GLM')
    save(fullfile(path,'geometricData',['geometricData_',strainName,'.mat']),'bootWorm',...
        'predictors','response','beta','betaShuffle','-v7.3')
end
end